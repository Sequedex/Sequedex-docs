###  Changelog.
#
#    Mathilde, Friday,   Jan 4, 2013
#    Nick      Saturday, Jan 5, 2013
#    Ben       Sunday,   July 7, 2013 added labels to plots

#####===========================================================
###  This file contains a number of functions that are useful
###  for analyzing the output from sequescan.  It contains the
###  following functions:
###
###  Read.sequedex:  read sequedex output files and tree
###  Read.tree    :  read the phylogenetic tree
###  Read.phylo   :  read sequedex phylogenetic data and tree 
###  Extract.clade:  extract clade and associated node values
###  Plot.profile :  simple plot of a phylogenetic profile
###  Zoom.profile :  a function to select interactively subtrees to plot
###  Diff.profile :  plot significant differences between two phylogenetic profiles
###
###  Auxilliary functions:
###  mkTable      :  extract desired data from list returned by Read.sequedex
###  Path.to.root :  find the path from a given node to the root
###  Simplify.label: returns simplified labels
###
#####===========================================================

require(ape)

#================================================================
# Validate
#----------------------------------------------------------------
#  A function that reads the completion statistics and validates
#  that the sequedex output completed
#================================================================
#  Input:
#   root.dir
#----------------------------------------------------------------
#  Output:
#    list of filename and completion statistics
#================================================================

Validate <- function(root.dir){
  all.files   <- list.files(path=root.dir,recursive=T,full.name=T)
  idx <- grep("stats.tsv",all.files)
  if ( length(idx) == 0 ) stop(paste("No sequedex output files found in",root.dir))
  sequedex.stat <- vector("list",length(idx))
  for ( k in 1:length(idx) ){
     in.stat <- read.table(all.files[idx[k]],sep="\t")
     sequedex.stat[[k]]$filename <- as.character(in.stat[3,2])
     sequedex.stat[[k]]$completion <- as.numeric(as.character(in.stat[4,2]))
     sequedex.stat[[k]]$stat <- as.numeric(as.character(in.stat[c(8,15:19,21),2]))
     names(sequedex.stat[[k]]$stat) <- as.character(in.stat[c(8,15:19,21),1])
  }
  if ( sum( sapply( sequedex.stat,FUN=function(x) x$completion < 100 ) ) > 0 ) warning("Not all Sequescan runs are completed")
  return(sequedex.stat)
}

#================================================================
# Read.sequedex:
#  A function to read the phylogenetic, functional or WDW profiles 
#  generated by sequedex
#================================================================
#  Input:
#     root.dir  = root directory under which sequedex stores the analysis files
#     type.ref  = reference database (tol, bact, virus)
#     type.tab  = name of table (phylogeny, function, xseed)  
#----------------------------------------------------------------
# Parameters
#     name.char = number of character for shortening name
#     type.col = column name to be extracted   
#----------------------------------------------------------------

Read.sequedex <- function(root.dir,type.ref="Life2550",type.tab="who"){

#  set internal parameters.   
   name.char <- -1
   
#  get list of input subdirectories and identify which ones might contain data
#  need to have fasta, fna, fastq or fq in directory name.
   listDir   <- list.dirs(path=root.dir,recursive=T)
   dir.type  <- c("fasta","fastq","fna","fq")
   dir.idx   <- numeric(0)
   for ( k in 1:4 ) dir.idx <- c(dir.idx,grep(dir.type[k],listDir))
   dir.idx   <- sort(unique(dir.idx))
   
#  if no directory with correct name, stop and return an error message
   if ( length(dir.idx) == 0 ) stop(paste("no sequedex directory found under",root.dir))
   listDir   <- listDir[dir.idx]

#  identify within selected directory that might contain sequedex output
#  look for (1) tsv$, (2) reference database and (3) table type   
   list.files <- vector("list",length(listDir))
   for ( k in 1:length(listDir) ){
      list.files[[k]] <- list.files(listDir[k])
# select  tsv files
      idx.files <- grep("tsv$",list.files[[k]])
      list.files[[k]] <- list.files[[k]][idx.files]
      if ( length(idx.files) == 0 ) next
# select on reference database
      idx.files <- grep(type.ref,list.files[[k]])
      list.files[[k]] <- list.files[[k]][idx.files]
      if ( length(idx.files) == 0 ) next
# select on table type
      idx.files <- grep(type.tab,list.files[[k]])
      list.files[[k]] <- list.files[[k]][idx.files]
   }
   
#  if no files are found, stop and return an error message
   nfiles <- sum( sapply( list.files,FUN=length ) )
   if ( nfiles == 0 ) stop( paste("No data file of desired type found under",root.dir) )
   
#  remove directories with no data files 
   idx.dir <- (sapply( list.files, FUN=length ) > 0)
   listDir <- listDir[idx.dir]
   list.files <- list.files[idx.dir]

#  expand filename to include the entire path
   filename <- vector("list",length(listDir))
   Dname <- vector("list",length(listDir))
   for ( k in 1:length(listDir) ){
     filename[[k]] <- paste(listDir[k],list.files[k],sep="/")
     tt=unlist(strsplit(listDir[k],"/"))
     print(length(unlist(tt)))
     Dname[k]=tt[length(unlist(tt))]  #
   }
   filename <- unlist(filename)

#  read in the data  
   data.list <- vector("list",length(filename))
   for ( k in 1:length(filename) ){
     data.list[[k]] <- read.table(filename[k],sep="\t",header=T,comment.char="")
   }
   tmp <- strsplit(unlist(list.files),".fastq")
   tmp <- sapply(tmp,FUN=function(x) x[1])
#   names(data.list) <- tmp
   names(data.list) <- Dname
   if ( name.char > 0 ) names(data.list) <- substr(unlist(list.files),1,name.char)

   return(data.list)
}

#================================================================
# Read.tree:  read associated phylogenetic tree
#================================================================
#  Input:
#     tree.file = reference tree filename
#     type.ref  = reference database (tol, bact, virus)
#----------------------------------------------------------------

Read.tree <- function(tree.file,colors=TRUE,sat=1){
#
#   parameter for simplify:  n.wrd
    n.wrd <- 2

#   identify the type of tree from extension  
    tmp.split <- unlist(strsplit(tree.file,"\\."))
    tree.type <- tmp.split[length(tmp.split)]
    switch( match(tree.type,c("nexus","newick"),nomatch=3),
            tree <- read.nexus(tree.file),
            tree <- read.tree(tree.file),
            stop(paste(tree.file,"is not of newick or nexus type"))) 

#   add rownames to edge file
    n.edge <- length(tree$edge[,1])
    rownames(tree$edge) <- as.character(seq(1,n.edge))
    
#   make simplified names
    tree$simple.tip.label <- Simplify.label(tree$tip.label,n.wrd)

#   add colors to edges
    if ( colors ){
      n.edge    <- length(tree$edge[,1]) 
      jumps     <- diff(tree$edge[,1])
      jumps.idx <- c(0,jumps < -50)
      n.col     <- n.edge + sum(jumps.idx)*75
      col.list  <- rainbow(n.col,s=sat)
      col.idx   <- 1:n.edge + 75*cumsum(jumps.idx)
      col.edge  <- col.list[col.idx]
      names(col.edge) <- as.character(seq(1,n.edge))
      tree$edge.color <- col.edge
    }
    
    return(tree)    
}

#

#================================================================
# Read.phylo:  read phylogenetic data and tree 
#================================================================
#  Input:
#     root.dir  = root directory of sequedex data files
#     tree.file = reference tree filename
#     type.ref  = reference database (tol, bact, virus)
#     data.type = column name (total,single_sig,single_node,monophyletic,non_monophyl)
#----------------------------------------------------------------

Read.phylo <- function(root.dir,tree.file,type.ref="Life",data.type="total"){
  
#   read data from sequedex
   data.list <- Read.sequedex(root.dir,type.ref)
   
#  construct a data.frame of selected columns, add row and column names
   idx.col <- match(data.type,names(data.list[[1]]),nomatch=-1)
   if ( idx.col == -1 ) stop(paste(data.type,"no found in datafile"))
   DD <- data.frame(sapply(data.list,FUN=function(x,idx) x[,idx],idx=idx.col))
   rownames(DD) <- data.list[[1]]$id
   colnames(DD) <- names(data.list)
   
#  read phylogenetic tree
   tree <- Read.tree(tree.file)
   
   #  verify that the size of the tree matches read data  
   if ( tree$Nnode != dim(DD)[1] ) stop(paste("size of",tree.file,"does not match input data"))
   
   #  [WARNING --- HACK] assume node labels from sequedex are in the correct order
   tree$node.label <- rownames(DD)
   tree$data <- DD
   
    return(tree)
}

#================================================================
# Extract.clade:  extract a clade and associated data and attributes
#================================================================
#  Input:
#     tree  = tree with (or without) $node.value
#     node  = index of name of node
#----------------------------------------------------------------
#
Extract.clade <- function(tree,node){
#  parameter for number of word to be return in Simplify.label  
   n.wrd <- 2

#  decide if node is a node name or a node id  
   if ( is.character(node) ){
    if ( is.na(match(node,tree$node.label,nomatch=NA) ) ) stop(paste(node,"not a valid node name"))
  }
   
   subtree <- extract.clade(tree,node) 
   if ( length(subtree$data) > 0 ) subtree$data <- tree$data[subtree$node.label,]
   if ( length(subtree$simple.tip.label) > 0) subtree$simple.tip.label <- Simplify.label(subtree$tip.label,n.wrd)
   if ( length(subtree$edge.color) > 0 ) subtree$edge.color <- tree$edge.color[rownames(subtree$edge)]
  
   return(subtree)
}

#================================================================
# Plot.profile:  plot node.value on tree
#================================================================
#  Input:
#     tree      = tree
#     nnode     = node to be extracted
#     Val       = data to be plotted, or variable name in tree$data, or variable index in tree$data
#     sCol      = vector of colors for symbols.  Default="blue"
#     type      = same as for plot.phylo
#     tip.frq   = n (0=none,1=all,k=every k^th)
#     simple.name  = T,  use simplified names
#     triangle  = F,  force use of triangles, even if all symboles are positive 
#----------------------------------------------------------------
#
Plot.profile <- function(tree,Val,nnode=0,
                         tip.frq=10, 
                         simple.name=TRUE, 
                         sCol="blue", 
                         triangle=FALSE,
                         type="unrooted",
                         use.edge.length=FALSE,
                         show.tip.label=TRUE,
                         root.edge=FALSE,
                         print.marg=TRUE){

#  Val can take three types of values:  a variable name in tree$data, and index in tree$data,
#  or a vector of values of length tree$Nnode.  
#  Identify the type of input, set dat variable or report an error
  action <- 3
  if ( is.character(Val) ) action <- 1
  if ( is.numeric(Val) & (length(Val)==1) ) action <- 2
  switch( action,
          { idx <- match(Val,colnames(tree$data),nomatch=-1)
          if ( idx == -1 ) { stop(paste(Val,"not a variable name of tree$data")) }
          dat <- tree$data[,idx] 
          varname <- Val  }, 
          { if ( Val > dim(tree$data)[2] ) stop("index out of bound")
            if ( Val < 0 ) stop("index out of bound")
            dat <- tree$data[,Val] 
            varname <- colnames(tree$data)[Val]},
          { if ( length(Val) != tree$Nnode ) { stop("length of Val does not match number of nodes") }
          dat <- Val
          varname <- "vector"} )
  names(dat) <- tree$node.label
#  select simple or long tip label and white tip labels with the desired frequency
  if (simple.name){
    Simplify.label(tree$tip.label, n.wrd=2)
  }
  if ( tip.frq > 0 ){
     idx <- (seq(1,length(tree$tip.label)) %% tip.frq) != 0
     tree$tip.label[idx] <- ""
    }
 
#  extract the subtree
   if ( is.numeric(nnode) ) nnode <- tree$node.label[nnode+1] 
   if ( is.na(match(nnode,tree$node.label,nomatch=NA)) ) stop(paste(nnode,"not a valid node name in tree"))
   
   subtree <- Extract.clade(tree,nnode)
   dat.sub <- dat[subtree$node.label]
  
   plot.phylo(subtree, type, use.edge.length=use.edge.length,
              edge.color=subtree$edge.color,
              show.tip.label=show.tip.label,
              root.edge=root.edge,
              label.offset=2*min(subtree$edge.length),
              lab4ut="axial",cex=1.0)

  if ( print.marg ) {
    mtext(text=varname,side=3, line=0)
    mtext(text=paste("The fraction of counts for this subtree is", round(100*sum(dat.sub)/sum(dat),2), "%",sep=" "),side=1, line=0)
  }
#  two types of plotting behavior:  circles if all the values in dat are non-negative
#                                :  triangles if multiple signs

  ccex <- 3*sqrt(abs(dat.sub)/max(abs(dat.sub)))
  action <- 1
   if (sum( dat.sub < 0 ) > 0) action <- 2
   if ( triangle ) action <- 2
   switch( action, { 
           nodelabels("",frame="none",pch=20,cex=ccex,col=sCol) },{ 
           idx.up <- (dat.sub > 0)
           nodelabels("",frame="none",pch=24,
                      cex=(idx.up*ccex),col=sCol)
           nodelabels("",frame="none",pch=25,cex=((!idx.up)*ccex),col=sCol)})
  
  # Create a legend 
  
  sseq <- pretty(dat.sub,n=5)
  sseq <- sseq[sseq > 0]
  ssize <- 3*sqrt(sseq)/sqrt(max(dat.sub))
  #plot(c(0,1),c(0,1),type="n",xlab="",ylab="")
  legend("bottomright",as.character(sseq),pch=20,pt.cex=ssize, col="blue")
}

#==================================================================
# Zoom.profile:  plot node.value on tree, and interactively select subtree
#==================================================================
#  Input:
#     tree         = tree
#     Val          = data to be plotted, or variable name in tree$data, or variable index in tree$data
#     tree.out     = return subtree (default=F)
#----------------default variables of Plot.profile-----------------
#     sCol         = vector of colors for symbols.  Default="blue"
#     type         = same as for plot.phylo
#     n.label      = approximate number of labels.  no labels=0, default=30
#     simple.name  = T,  use simplified names
#     triangle     = F,  force use of triangles, even if all symboles are positive 
#----------------------------------------------------------------
#
Zoom.profile <- function(tree, Val, tree.out=F,
                         n.label=30, simple.name=TRUE, sCol="blue", triangle=FALSE,
                         type="unrooted", use.edge.length=FALSE, print.fraction=TRUE){

    Plot.profile(tree,Val,show.tip.label=F,
                 type=type,use.edge.length=F,
                 triangle=triangle,sCol=sCol,simple.name=simple.name)
    nnode <- identify.phylo(tree,labels=T)
    subtree <- Extract.clade(tree,as.character(nnode))
    if ( length(Val) > 1 ){
      names(Val) <- tree$node.label
      Val <- Val[subtree$node.label]
    }
    tip.frq <- trunc(length(subtree$tip.label)/n.label)
    Plot.profile(subtree,Val,type="phylogram",root.edge=T,
                 tip.frq=tip.frq,simple.name=simple.name,
                 use.edge.length=use.edge.length,
                 show.tip.label=T)
    if (print.fraction) {
#      mtext(text=paste("The fraction of counts for this subtree is", round(sum(subtree$data[,Val]/sum(tree$data[,Val]))*100,2), "%",sep=" "),side=1, line=0)
    }
    
    # Create a legend 
    
    sseq <- pretty(subtree$data[,Val],n=5)
    sseq <- sseq[sseq > 0]
    ssize <- 3*sqrt(sseq)/sqrt(max(subtree$data[,Val]))
    #plot(c(0,1),c(0,1),type="n",xlab="",ylab="")
    legend("bottomright", as.character(sseq),pch=20,pt.cex=ssize, col="blue")
    
    if ( tree.out ) return( subtree )  
}

#==================================================================
# Diff.profile:  plot standardized differences of profiles
#==================================================================
#  Input:
#     tree         = tree
#     Val1,Val2    = profiles to be differentiated; variable names in tree$data, indices,
#                    or two vectors
#----------------default variables of Plot.profile-----------------
#     type         = same as for plot.phylo
#     n.label      = approximate number of labels.  no labels=0, default=30
#     simple.name  = T,  use simplified names
#----------------------------------------------------------------
Diff.profile <- function(tree,Val1, Val2,type="unrooted", n.label=30, simple.name=T){
  
  #  Val1 and Val2 can take three types of values:  a variable name in tree$data, and index in tree$data,
  #  or a vector of values of length tree$Nnode.  
  #  Identify the type of input, set dat1 and dat2 variables or report an error
  action <- 3
  if ( is.character(Val1) ) action <- 1
  if ( is.numeric(Val1) & (length(Val1)==1) ) action <- 2
  switch( action,
{ idx1 <- match(Val1,colnames(tree$data),nomatch=-1)
  if ( idx1 == -1 ) { stop(paste(Val1,"not a variable name of tree$data")) }
  dat1 <- tree$data[,idx1] }, 
{ if ( Val1 > dim(tree$data)[2] ) stop("index out of bound")
  if ( Val1 < 0 ) stop("index out of bound")
  dat1 <- tree$data[,Val1] },
{ if ( length(Val1) != tree$Nnode ) { stop("length of Val does not match number of nodes") }
  dat1 <- Val1} )
  # Repeat the same process for the variable Val2
  action <- 3
  if ( is.character(Val2) ) action <- 1
  if ( is.numeric(Val2) & (length(Val2)==1) ) action <- 2
  switch( action,
{ idx2 <- match(Val2,colnames(tree$data),nomatch=-1)
  if ( idx2 == -1 ) { stop(paste(Val2,"not a variable name of tree$data")) }
  dat2 <- tree$data[,idx2] }, 
{ if ( Val2 > dim(tree$data)[2] ) stop("index out of bound")
  if ( Val2 < 0 ) stop("index out of bound")
  dat2 <- tree$data[,Val2] },
{ if ( length(Val2) != tree$Nnode ) { stop("length of Val does not match number of nodes") }
  dat2 <- Val2} )
  
  # Build the vector difference that will be used in Plot.profile
  #  Normalize the counts so that each column sums to one
  #  and apply variance stabilizing transform and calculate
  #  score for the difference (in standard deviations)
  tot.cnt1 <- sum(dat1)
  tot.cnt2<- sum(dat2)
  z1      <- asin( sqrt( dat1/tot.cnt1 ) )
  z2      <- asin( sqrt( dat2/tot.cnt2 ) )
  dif.z   <- 2*( z1 - z2 )/sqrt(1/tot.cnt1+1/tot.cnt2)
  Plot.profile(tree,dif.z,
                tip.frq=10, simple.name=simple.name, sCol="blue", triangle=TRUE,
                type=type,
                use.edge.length=FALSE,
                show.tip.label=TRUE,
                root.edge=F)
  return(dif.z)
  
}


#================================================================
# mkTable:  Function to extract table from data imported using Read.sequedex
#================================================================
#  Input:
#     data.list : output from Read.sequedex   
#     col.name  : name of index of column to be extracted
#----------------------------------------------------------------

mkTable <- function(data.list,col.name){
  action <- 1
  if ( is.character(col.name) ) action <- 2
  switch( action , {
    if ( length(col.name) > 1) stop("col.name needs to be an integer")
    if ( (col.name < 0) | ( col.name > dim(data.list[[1]])[2] ) ) stop("col.name out of range")
    idx.col <- col.name } , {
    idx.col <- match(col.name,names(data.list[[1]]),nomatch=-1)
    if ( idx.col == -1 ) stop(paste(col.name,"no found in datafile")) })
  DD <- data.frame(sapply(data.list,FUN=function(x,idx) x[,idx],idx=idx.col))
  rownames(DD) <- data.list[[1]]$id
  colnames(DD) <- names(data.list)
  return(DD)
}

#================================================================
# Simplify.label:  simplifies tip labels
#================================================================
#  Input:
#     tip.label:  (long) tip labels 
#     n.wrd    :  number of words to return (default=2)
#----------------------------------------------------------------
Simplify.label <- function(tip.label,n.wrd=2){
  tmp.name <- strsplit(tip.label,"_")
  tmp.name <- lapply(tmp.name,FUN=function(x,n.wrd){
    if ( length(x) < n.wrd ) x <- c(x,rep("",n.wrd-length(x)))
    return(x) }, n.wrd=n.wrd )
  simple.name <- sapply(tmp.name,FUN=function(x,n.wrd) paste(x[1:n.wrd],collapse=" "), n.wrd=n.wrd)
  return(simple.name)
}


#================================================================
# Annotate: prints the node.labels and tip.labels for the relevant 
#(with a important number of counts) leaves and internal nodes
#================================================================
# Input:
#   coef.leaves is a coefficient between 0 and 1 
# that symbolizes the proportion of relevant leaves we want to show the tip.labels
#   coef.nodes is a coefficient between 0 and 1 
# that symbolizes the proportion of relevant internal nodes which we want to show the node.labels
#     Val          = data to be plotted, or variable name in tree$data, or variable index in tree$data
#------------------------------------------------------------------------------------------------------
Annotate <- function(tree, Val, coef.leaves, coef.nodes){
  
  action <- 3
  if ( is.character(Val) ) action <- 1
  if ( is.numeric(Val) & (length(Val)==1) ) action <- 2
  
  switch( action,
{ idx <- match(Val,colnames(tree$data),nomatch=-1)
  if ( idx == -1 ) { stop(paste(Val,"not a variable name of tree$data")) }
  dat <- tree$data[,idx] 
  }, 
{ if ( Val > dim(tree$data)[2] ) stop("index out of bound")
  if ( Val < 0 ) stop("index out of bound")
  dat <- tree$data[,Val] },
{ if ( length(Val) != tree$Nnode ) { stop("length of Val does not match number of nodes") }
  dat <- Val} )
  
  # Adding node labels for the relevant internal nodes
  nodelim <- floor(coef.nodes* length(dat))
  names(dat) <- seq(length(tree$tip.label)+1,(tree$Nnode+length(tree$tip.label)))
  dat <- rev(sort(dat))
  dat <- dat[1: nodelim]
  nodelabels(text=names(dat), node=as.numeric(names(dat)),col="black", bg="white", cex=0.6, frame="rect")
  
  # Adding tip labels for the relevant tips
  leaflim <- floor(coef.leaves*length(dat))
  tip.idx <- seq(1,1471)
  leaf <- rep(0,1471)
  names(leaf) <- seq(1,length(tree$tip.label))
  for (i in tip.idx){
  leaf[i] <- sum(PathToRoot(tree,i))
  }
  leaf <- rev(sort(leaf))
  leaf <- leaf[1: leaflim]
  tiplabels(text=tree$tip.label[as.numeric(names(leaf))], tip=as.numeric(names(leaf)),col="black", bg="white", adj=0.2,cex=0.8, frame="rect")
   
}

#================================================================
# All.paths: calculate path to the root for every leaf 
#                returns list of node.labels
#================================================================
#  Input:
#     tree : output extended phylogenetic tree 
#  Output:  A list with two components: nodes and edges
#----------------------------------------------------------------

All.paths <- function(tree){
   idx      <- (node.depth(tree) == 1)  # true for leafs
   leaf.idx <- seq_along(idx)[idx]      # index of leafs
   node.idx <- seq_along(idx)[!idx]     # index of nodes.
   n.leafs <- length(leaf.idx)
   node.nam <- tree$node.label
   names(node.nam) <- as.character(node.idx)
   root.idx <- seq_along(idx)[which.max(node.depth(tree))]
   
   E <- tree$edge   
   path <- vector("list",n.leafs)
   
   for ( k in 1:n.leafs ){
      pp <- leaf.idx[k]
      ee <- numeric(0)
      while ( pp[1] != root.idx ){
         ee <- c(which(E[,2]==pp[1]),ee)
         pp <- c(E[ee[1],1],pp)
      }
      path[[k]]$node <- node.nam[as.character(rev(pp[-length(pp)]))]
      names(path[[k]]$node) <- as.character(rev(pp[-length(pp)]))
      path[[k]]$edge <- rev(ee)
   }
   names(path) <- tree$tip.label
   return(path)
}

#================================================================
#  Monophyl.sum
#    function that is applied the data matrix of a tree
#    calculates, for each leaf, the sum of values along the path to the root.
#----------------------------------------------------------------
#  Input:  Tree
#  Output: matrix # leaves x # column(tree$data)
#================================================================
Monophyl.sum <- function(tree){
   paths.root <- All.paths(tree)
   n.leafs <- length(paths.root)
   sum.root <- matrix(0,n.leafs,dim(tree$data)[2])
   rownames(sum.root) <- tree$tip.label
   colnames(sum.root) <- colnames(tree$data)
   for ( k in 1:n.leafs ){
      sum.root[k,] <- apply(tree$data[ paths.root[[k]]$node,],2,sum)
   }
   return(sum.root)
}

#================================================================
#  TopK
#    function finds top monophylogenetic sums.
#----------------------------------------------------------------
#  Input:  Tree
#          Col: column id of data matrix --- NOT ROBUST YET
#          K: Number of tops
#  Output: list of counts along the path, names of leaves
#================================================================

TopK <- function(Tree,Col,K=25){
  TT <- Tree
  topK <- vector("list",length=K)
  paths.root <- All.paths(TT)
  MS <- Monophyl.sum(TT)
  for ( k in 1:K ){
    idx <- seq_along(MS[,Col])[MS[,Col] == max(MS[,Col])]
    tot <- MS[idx[1],Col]
    tmp <- TT$data[,Col]
    names(tmp) <- rownames(TT$data)
    ppp <- rev(tmp[paths.root[[idx[1]]]$node])
    tmp[paths.root[[idx[1]]]$node] <- 0
    topK[[k]] <- list(names(paths.root[idx]),ppp)
    TT$data[,Col] <- tmp
    MS <- Monophyl.sum(TT)
  }
  return(topK)
}


#================================================================
# Path.to.root:  calculate path to root, 
#                returns list of values along that path or produces a plot
#================================================================
#  Input:
#     tree : output extended phylogenetic tree 
#     node : name node from which path is calculated.  node=-1, interactive
#----------------------------------------------------------------

Path.to.root <- function(tree,node,plot=F,Val=NULL){
  n.labels <- c(tree$tip.label,tree$node.label)
  idx <- seq_along(n.labels)
  names(idx) <- n.labels
  E <- tree$edge
  if ( node == -1 ) {
    plot.phylo(tree, "unrooted",
               use.edge.length=F,
               edge.color=tree$edge.color,
               show.tip.label=F,
               root.edge=root.edge,
               label.offset=2*min(tree$edge.length),
               lab4ut="axial",cex=0.6)
    node <- unlist(identify.phylo(tree,labels=T))
    }
  
    }

Leaf.color <- function(tree){
  Ndepth <- node.depth(tree)
  leaf.idx <- seq_along(Ndepth)[Ndepth==1]
  leaf.color <- tree$edge.color[match(leaf.idx,tree$edge[,2])]
  return(leaf.color)
}

########### Old functions.  Not yet robust

PathToRoot <- function(tree,node.idx){
  TT <- tree$edge
  path.to.root <- node.idx
  new.node <- node.idx
  root.idx <- which.max(node.depth(tree))
  while(new.node != root.idx){
    new.node <- TT[which(TT[,2]==new.node),1]
    path.to.root <- c(path.to.root,new.node)
  }
  return(path.to.root)
}

Clade <- function(tree,node.idx){
  TT <- tree$edge
  descendent <- node.idx
  new.descendent <- node.idx
  root.idx <- which.max(node.depth(tree))
  while ( max(new.descendent) >= root.idx ){
    new.descendent <- TT[TT[,1] %in% new.descendent,2]
    descendent <- c(descendent,new.descendent)
  }
  tips <- descendent[descendent < root.idx]
  nodes <- descendent[!(descendent < root.idx)]
  return(list(nodes=nodes,tips=tips))
}

#------------------------------------------------------
# Function Read graph to create the functional graph
#------------------------------------------------------
Read.graph <- function(graph.file, col=TRUE, sat=1){
# Read the file that contains the graph structure. 
  tmp <- scan(graph.file,what="",sep="\n")
  tmp.split <- strsplit(tmp,"\t")
   
# Identification of the functional level (are gonna be the leaves of the functional tree)
  sid <- sapply(tmp.split,FUN=function(x) x[1])
# Level 1
  L1  <- sapply(tmp.split,FUN=function(x) x[4])
  L1  <- L1[-c(1,length(L1))]
# Level 2
  L2  <- sapply(tmp.split,FUN=function(x) x[5])
  L2  <- L2[-c(1,length(L2))]
# Subsystem level
  L3  <- sapply(tmp.split,FUN=function(x) x[6])
  L3  <- L3[-c(1,length(L3))]
  
# Creation of the edges
# Rename the levels:
  L1sid  <- paste("L1",L1)
  L2sid  <- paste("L2",L2)
  L3sid  <- paste("L3",L3)
  L12 <- split(L2sid, L1sid)

# Create the first level of edgelist
x=c("Y large scale","X small scale",
"X small scale","X1 molecules",
"X1 molecules","1 L1 Amino Acids and Derivatives",
"X1 molecules","2 L1 Carbohydrates",
"X1 molecules","6 L1 Cofactors, Vitamins, Prosthetic Groups, Pigments",
"X1 molecules","12 L1 Metabolism of Aromatic Compounds",
"X1 molecules","16 L1 Nucleosides and Nucleotides",
"X1 molecules","26 L1 Secondary Metabolism",
"X small scale","X2 elements",
"X2 elements","10 L1 Iron acquisition and metabolism",
"X2 elements","15 L1 Nitrogen Metabolism",
"X2 elements","19 L1 Phosphorus Metabolism",
"X2 elements","21 L1 Potassium metabolism",
"X2 elements","28 L1 Sulfur Metabolism",
"X small scale","X3 information",
"X3 information","7 L1 DNA Metabolism",
"X3 information","22 L1 Protein Metabolism",
"X3 information","23 L1 RNA Metabolism",
"X small scale","X4 energy",
"X4 energy","9 L1 Fatty Acids, Lipids, and Isoprenoids",
"X4 energy","20 L1 Photosynthesis",
"X4 energy","25 L1 Respiration",
"X4 energy","31 L1 Ribosome",
"Y large scale","Y1 processes",
"Y1 processes","3 L1 Cell Division and Cell Cycle",
"Y1 processes","4 L1 Cell Wall and Capsule",
"Y1 processes","8 L1 Dormancy and Sporulation",
"Y1 processes","11 L1 Membrane Transport",
"Y1 processes","14 L1 Motility and Chemotaxis",
"Y1 processes","24 L1 Regulation and Cell signaling",
"Y1 processes","27 L1 Stress Response",
"Y large scale","Y2 virulence",
"Y2 virulence","17 L1 Phages, Prophages, Transposable elements",
"Y2 virulence","18 L1 Phages, Prophages, Transposable elements, Plasmids",
"Y2 virulence","29 L1 Virulence",
"Y2 virulence","30 L1 Virulence, Disease and Defense",
"Y large scale","Y3 etc",
"Y3 etc","5 L1 Clustering-based subsystems",
"Y3 etc","13 L1 Miscellaneous")

edgelist=t(array(x,c(2,39)))

# Add the second level of edgelist
  level2 <- cbind(L1sid,L2sid)
  level2 <- unique(level2)  
# Add this level to edgelist
  edgelist <- rbind(edgelist, level2) 
# Add numbers to level 1 and 2 of edgelist to avoid multiple edges between vertices of level 1 and 2
# and creating a vector of color for those two levels of edges.
  code.col <-""
# For the first level of edges
  number <- seq(1: 39)
  code.col[number]<- rainbow(length(number),s=1 )
#  edgelist[1:39] <- paste(number,edgelist[grep("L1",edgelist[,2]),2])
# For the second level of edges
  number <- 1
  number.col <- 1
  code.col <- c(code.col,code.col[number])
  edgelist[40,1] <- paste(number, edgelist[40,1])
   for (i in 1:203){
  
    if( paste(number,edgelist[(i+1+39),1]) == edgelist[(39+i),1]){
      number.col <- c(number.col, number)
      edgelist[(i+1+39),1] <- paste(number, edgelist[(i+1+39),1])
      code.col <- c(code.col, code.col[number])
    } 
    else{
      number <- number +1
      number.col <- c(number.col, number)
      edgelist[(i+1+39),1] <- paste(number, edgelist[(i+1+39),1])
      code.col <- c(code.col,code.col[number])
    } 
  }

  n <- dim(edgelist)[1]
  number <- seq(1,length((length(L12)+9):n))
  edgelist[(length(L12)+9):n,2] <- paste(number, edgelist[(length(L12)+9):n,2])
# Add the third level of edgelist 
# (the order of the L2 column of level3 is the same as the L2 column of level 2)
  edgelist <- rbind (edgelist, cbind(L2sid,L3sid))
# Attribute numbers to the third level of edges to avoid multiple edges between vertices of levels 2 and 3
  number <- 1
  code.col <- c(code.col, code.col[1])
  
  edgelist[244,1] <- paste(number, edgelist[244,1]) 
  for (i in 1:962){
     
     if( paste(number,edgelist[(i+1+243),1]) == edgelist[(243+i),1]){
       edgelist[(i+1+243),1] <- paste(number, edgelist[(i+1+243),1])
       code.col <- c(code.col, code.col[number.col[number]])
      
     } 
     else{
       number <- number +1
       edgelist[(i+1+243),1] <- paste(number, edgelist[(i+1+243),1])
       code.col <- c(code.col, code.col[number.col[number]])
     }
  }
  
# Separate the three parts of edgelist
  Level1 <- edgelist[grep("L1", edgelist[,2]),]
  Level2 <- edgelist[grep("L1",edgelist[,1]),]
  Level3 <- edgelist[grep("L3",edgelist[,2]),]
    
# Build the functional tree using the edgelist and the function graph.data.frame
  edgelist <- data.frame(edgelist)
  graph <- graph.data.frame(edgelist,directed=F)
  
# Add some attributes to the tree:
  
#leaves
  graph$leaves <- L3
  
# graph names ( write the family names to the graph)
  graph$families <- c("Y large scale","X small scale",
"X1 molecules","X2 elements","X3 information","X4 energy","Y1 processes","Y2 virulence","Y3 etc",
"1 L1 Amino Acids","2 L1 Carbohydrates","3 L1 Cell Cycle","4 L1 Cell Wall","5 L1 Clusters","6 L1 Cofactors",
"7 L1 DNA","8 L1 Dormancy","9 L1 Lipids","10 L1 Iron","11 L1 Membrane","12 L1 Aromatic Compounds",
"13 L1 Miscellaneous","14 L1 Motility","15 L1 Nitrogen","16 L1 Nucleotides","17 L1 Phages1","18 L1 Phages2",
"19 L1 Phosphorus","20 L1 Photosynthesis","21 L1 Potassium","22 L1 Protein","23 L1 RNA","24 L1 Regulation","25 L1 Respiration",
"26 L1 Secondary Metabolism","27 L1 Stress","28 L1 Sulfur","29 L1 Virulence1","30 L1 Virulence2","31 L1 Ribosome")

# distances edges
# graph edgelist
  graph$edgelist <- edgelist

# Color the edges
 if (col== TRUE){ 
   graph$color <- code.col
 }
# Return the graph with his attributes
  return(graph)
}
  

Read.sequedexf <- function(root.dir, type.ref="Life2550", type.tab="what"){
  
  
  #  get list of input subdirectories and identify which ones might contain data
  #  need to have fasta, fna, fastq or fq in directory name.
  listDir   <- list.dirs(path=root.dir,recursive=T)
  dir.type  <- c("fasta","fastq","fna","fq")
  dir.idx   <- numeric(0)
  for ( k in 1:4 ) dir.idx <- c(dir.idx,grep(dir.type[k],listDir))
  dir.idx   <- sort(unique(dir.idx))
  
  #  if no directory with correct name, stop and return an error message
  if ( length(dir.idx) == 0 ) stop(paste("no sequedex directory found under",root.dir))
  listDir   <- listDir[dir.idx]
  
  #  identify within selected directory that might contain sequedex output
  #  look for (1) tsv$, (2) reference database and (3) table type   
  list.files <- vector("list",length(listDir))
  for ( k in 1:length(listDir) ){
    list.files[[k]] <- list.files(listDir[k])
    # select  tsv files
    idx.files <- grep("tsv$",list.files[[k]])
    list.files[[k]] <- list.files[[k]][idx.files]
    if ( length(idx.files) == 0 ) next
    # select on reference database
    idx.files <- grep(type.ref,list.files[[k]])
    list.files[[k]] <- list.files[[k]][idx.files]
    if ( length(idx.files) == 0 ) next
    # select on table type
    idx.files <- grep(type.tab,list.files[[k]])
    list.files[[k]] <- list.files[[k]][idx.files]
  }
  
  #  if no files are found, stop and return an error message
  nfiles <- sum( sapply( list.files,FUN=length ) )
  if ( nfiles == 0 ) stop( paste("No data file of desired type found under",root.dir) )
  
  #  remove directories with no data files 
  idx.dir <- (sapply( list.files, FUN=length ) > 0)
  listDir <- listDir[idx.dir]
  list.files <- list.files[idx.dir]
  
  #  expand filename to include the entire path
  filename <- vector("list",length(listDir))
  for ( k in 1:length(listDir) ){
    filename[[k]] <- paste(listDir[k],list.files[k],sep="/")
  }
  filename <- unlist(filename)
  
  #  read in the data 
  tmp <- scan(filename[1],what="",sep="\n")
  tmp.split <- strsplit(tmp,"\t")
  graph.data <- matrix(0,nrow=length(tmp.split),ncol= length(filename))

  for ( k in 1:length(filename) ){
    tmp <- scan(filename[k],what="",sep="\n")
    tmp.split <- strsplit(tmp,"\t")    
    graph.data[,k]  <- sapply(tmp.split,FUN=function(x) as.numeric(x[3]))  
  } 
  # BE CAREFUL! If the data is in the old format dim(graph.data)[1]-1 shouldn't be removed from graph.data.
#  graph.data <- graph.data[-c(1,dim(graph.data)[1],dim(graph.data)[1]-1)
  graph.data <- graph.data[-c(1,dim(graph.data)[1])
                          ,]
#  colnames(graph.data) <- sapply(strsplit(listDir,"/"), FUN= function(x) x[2])
  colnames(graph.data) <- listDir
  return (graph.data)
}

#-----------------------------------------------------------------------------------------------------
# Function Read.functional to read a functional graph with a fragments data.frame as an attribute of it
#-----------------------------------------------------------------------------------------------------
  Read.functional <- function(root.dir, graph.file,layout=layout.fruchterman.reingold,dim=2, type.ref="Life2550", data.type="function"){
    # read data
    graph.data <- Read.sequedexf(root.dir, type.ref="Life2550",type.tab="what")
    # read functional graph
    graph <- Read.graph (graph.file, col=T, sat=1)
    
    #  verify that the size of the tree matches read data  
    if ( length(graph$leaves) != dim(graph.data)[1] ) stop(paste("size of",graph.file,"does not match input data"))
    
    #  [WARNING --- HACK] assume functional labels from sequedex are assumed to be in the correct order
    rownames(graph.data) <- graph$leaves
    graph$data <- graph.data
    layout <- layout(graph, dim= dim)
    graph$layout <- layout
    return(graph)
  }
 
#-------------------------------------------------------
# Function plot fragments value on the functional graph
#-------------------------------------------------------

  plot.graph <- function(graph,
             Val, 
             simple.name= T,
             leave.label= T,
             scol= "red",
             shape= "circle",
             sign= F, 
             dimension= 2, 
             cex=0.6,
             tmain="")
{
#  Val can take three types of values:  a variable name in graph$data, and index in graph$data,
#  or a vector of values of length graph$leaves.  
#  Identify the type of input, set dat variable or report an error
action <- 3
if ( is.character(Val) & length(Val)==1 ) action <- 1
if ( is.numeric(Val) & (length(Val)==1) ) action <- 2

switch( action,
{ idx <- match(Val,colnames(graph$data),nomatch=-1)
  if ( idx == -1 ) { stop(paste(Val,"not a variable name of graph$data")) }
  dat <- as.numeric(graph$data[,idx]) 
  title=colnames(graph$data)[idx]}, 
{ if ( Val > dim(graph$data)[2] ) stop("index out of bound")
  if ( Val < 0 ) stop("index out of bound")
  dat <- as.numeric(graph$data[,Val])
  title=colnames(graph$data)[Val] },
{ if ( length(Val) != dim(graph$data)[1]) { stop("length of Val does not match number of functions") }
  dat <- as.numeric(Val)
  title=tmain} )
              
# Define the size of the vertices.
ccex <- matrix(nrow= length(V(graph)), ncol=1,data=0)
ccex[(length(V(graph))-length(dat)+1):length(V(graph))] <- 10*sqrt(abs(dat)/max(abs(dat)))

# Red or Blue
#  Two types of plotting behavior:  red if all the values in dat are non-negative
#                                :  red and blue if multiple signs (blue= decrease, red= increase)

 if (sign){
   scol <- matrix(nrow=length(V(graph)),ncol=1, data=0)
   scol[(length(V(graph))-length(dat)+1):length(V(graph))] <- (dat > 0)*2 + (dat < 0)*4 + (dat==0)*0
 }
else{
  scol1 <- scol
  scol <- matrix(nrow=length(V(graph)),ncol=1, data=0)
  scol[(length(V(graph))-length(dat)+1):length(V(graph))] <- scol1
}
# Define the vector shape for the shape of the vertices
if(is.character(shape)& length(shape)==1){
  Shape <- matrix(nrow=length(V(graph)), ncol=1, data="none")
  for (i in (length(V(graph))-length(dat)+1):length(V(graph))){
    if (dat[i-(length(V(graph))-length(dat))]==0){
      Shape[i] <- "none"
    }
    else{
      Shape[i] <- shape
    }
  }
    
  }
  pch = 20
if(length(shape)==length(V(graph))){
  Shape <- shape
}
# Add families names
if (simple.name== F){
labels <- c(graph$families, rep("",length(V(graph))-length(graph$families)))
}
else{
  labels <- rep("",length(V(graph)))
}

# Add some leave label if wanted:
#if (leave.label== T){
#  labels <- ""
#  labels[dat !=0] <- graph$leaves[dat !=0]
#  labels[is.na(labels)] <- ""
#  labels <- c(rep("",length(V(graph))-length(graph$leaves)), labels)
#}
#else{
#  labels <- rep("",length(V(graph)))
#}

# PLot the graph (with different parameters as: shape, size, layout and dimension)

if(dimension==2){
    plot.igraph(graph,vertex.label=labels, vertex.label.color= "black",vertex.label.cex= cex, vertex.size= ccex, vertex.shape= Shape, vertex.color= scol, edge.color= graph$color, main=title)
    }
else{
    rglplot(graph,vertex.label=labels,vertex.label.color= "black", vertex.label.cex= cex, vertex.size=ccex, vertex.shape=Shape, vertex.color= "blue", edge.color= graph$color)
            }
# Create a legend 
# sseq <- pretty(dat,n=5)
# sseq <- sseq[sseq > 0]
# ssize <- 3*sqrt(sseq)/sqrt(max(dat))
# legend("bottomright",as.character(sseq),pch=pch,title="Size",pt.cex= ssize, col=scol, pt.bg= scol, bty="n", y.intersp=1.5)

#         if(dimension==2){
#             idx.up <- (dat > 0)
#             graph$layout <- layout
#             plot.igraph(graph,vertex.label=NA,vertex.size=ccex, vertex.shape=shape, vertex.color= scol, edge.color= graph$color)
#             }
#         else{
#             graph$layout <- layout.fruchterman.reingold(graph, dim=3)
#             rglplot(graph,vertex.label=NA,vertex.size=floor(as.numeric(dat)/1000), vertex.size2=as.numeric(dat)/100, vertex.color= scol, edge.color= graph$color)
#             }
#                 
#                  
#                  
#                  # Create a legend 
#                  sseq <- pretty(dat,n=5)
#                  sseq <- sseq[sseq !=0]
#                  sseq1 <- sseq[sseq > 0]
#                  sseq2 <- - sseq[sseq < 0]
#                  ssize <-  c(3*sqrt(sseq2/max(abs(dat))), 3*sqrt(sseq1/max(abs(dat))))
#                  #plot(c(0,1),c(0,1),type="n",xlab="",ylab="")
#                  legend("topright",as.character(sseq),pch=pch,pt.cex= ssize,title= "Size", col="black", pt.bg= "white", bty="n", y.intersp=0.5*max(ssize))
#                  if (length(alpha) > 1){
#                    legend( "bottomright", legend= paste(" alpha <=",c(rev(alpha), 1)), pt.cex= 2,title= "Colors", fill= c("red","magenta","cyan","green3"), y.intersp=1.25, bty="n")
#                  }
return(unique(labels))
                
             }

#------------------------------------------------------------------------------
# Function plot difference value between Val1 and Val2 on the functional graph |
#------------------------------------------------------------------------------
Diff.graph <- function(graph, Val1, Val2, dim=2, alpha= 0.000000001){
  
  #  Val1 and Val2 can take three types of values:  a variable name in tree$data, and index in tree$data,
  #  or a vector of values of length tree$Nnode.  
  #  Identify the type of input, set dat1 and dat2 variables or report an error
  action <- 3
  if ( is.character(Val1) & length(Val1)==1 ) action <- 1
  if ( is.numeric(Val1) & (length(Val1)==1) ) action <- 2
  switch( action,
{ idx1 <- match(Val1,colnames(graph$data),nomatch=-1)
  if ( idx1 == -1 ) { stop(paste(Val1,"not a variable name of tree$data")) }
  dat1 <- as.numeric(graph$data[,idx1]) 
  title1=colnames(graph$data)[idx1]}, 
{ if ( Val1 > dim(graph$data)[2] ) stop("index out of bound")
  if ( Val1 < 0 ) stop("index out of bound")
  dat1 <- as.numeric(graph$data[,Val1]) 
    title1=colnames(graph$data)[Val1]},
{ if ( length(Val1) != dim(graph$data)[1] ) { stop("length of Val does not match number of nodes") }
  dat1 <- as.numeric(Val1) 
    title1=as.character(tmain1)})
  # Repeat the same process for the variable Val2
  action <- 3
  if ( is.character(Val2) &length(Val2)==1 ) action <- 1
  if ( is.numeric(Val2) & (length(Val2)==1) ) action <- 2
  switch( action,
{ idx2 <- match(Val2,colnames(graph$data),nomatch=-1)
  if ( idx2 == -1 ) { stop(paste(Val2,"not a variable name of tree$data")) }
  dat2 <- as.numeric(graph$data[,idx2]) 
    title2=colnames(graph$data)[idx2]}, 
{ if ( Val2 > dim(graph$data)[2] ) stop("index out of bound")
  if ( Val2 < 0 ) stop("index out of bound")
  dat2 <- as.numeric(graph$data[,Val2]) 
    title2=colnames(graph$data)[Val2]},
{ if ( length(Val2) != dim(graph$data)[1] ) { stop("length of Val does not match number of nodes") }
  dat2 <- as.numeric(Val2)
   title2=as.character(tmain2)} )

title=paste(title1,"-",title2)
  
  # Build the vector difference that will be used in Plot.profile
  #  Normalize the counts so that each column sums to one
  #  and apply variance stabilizing transform and calculate
  #  score for the difference (in standard deviations)
  tot.cnt1 <- sum(dat1)
  tot.cnt2<- sum(dat2)
  z1      <- asin( sqrt( dat1/tot.cnt1 ) )
  z2      <- asin( sqrt( dat2/tot.cnt2 ) )
  dif.z   <- 2*( z1 - z2 )/sqrt(1/tot.cnt1+1/tot.cnt2)
  
  # Set colors for significant differences for a vector dif.
  sig   <- abs(dif.z) > qnorm(alpha/2,lower.tail=F)
  dif.z <- dif.z*sig
  dif.z <- c(rep(0,length(graph$data[,1])-length(dif.z)), as.numeric(dif.z))
  # plot the dif on the graph
  if (dim==2){
  plot.graph(graph,dif.z,simple.name= F,scol= "red", shape= "circle",sign= T,dimension= 2,cex=0.6, tmain=title)
  }
  if (dim==3){
  plot.graph(graph,dif.z,simple.name= F,scol= "red", shape= "circle",sign= T,dimension= 3,cex=0.6)
  }

  return(dif.z)
  
}
